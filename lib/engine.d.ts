/* @macrome
 * @generatedby @macrome/generator-typescript
 * @generatedfrom ./engine.ts#1645379750614
 * This file is autogenerated. Please do not edit it directly.
 * When editing run `npx macrome watch` then change the file this is generated from.
 */
import { Pattern, ContinuationResult, Result, ExpressionResult, MatchState, Width0Matcher, W0Context, Width1Matcher, Context } from './types';
type ExpressionState = {
  type: 'expr';
  expr: Expression;
};
type SuccessState = {
  type: 'success';
  expr: Expression | null;
  captures: Array<Array<string | null>>;
};
type ContinuationState = ContinuationResult;
type State = ExpressionState | ContinuationState | SuccessState;
export declare class Sequence {
  // An expression can be distributed into a sequence,
  // so a sequence may be an expression.
  state: State;
  matchState: MatchState;
  parentExpr: Expression; // next, prev in more standard terminology

  better: Sequence | null;
  worse: Sequence | null;
  constructor(state: ContinuationState, matchState: MatchState, expr: Expression);
  maybeHoist(): Sequence;
  remove(): Sequence | null;
  removeWorse(): Sequence;
  fail(): Sequence | null;
  succeed(successState: SuccessState): Sequence | null;
  replaceWith(result: Result, context: Context): Sequence | null;
  get next(): Sequence | null;
}
export declare class Expression {
  engine: Engine;
  best: Sequence;
  parentSeq: Sequence | null;
  isRoot: boolean;
  globalIdx: number;
  constructor(engine: Engine, result: ExpressionResult, globalIdx: number, parentSeq: Sequence | null);
  terminate(state: SuccessState | null): Sequence | null;
}
export declare class Engine {
  root: Expression | null;
  matcher: Width0Matcher;
  initialMatchState: MatchState;
  repetitionCount: number;
  captures: Array<Array<string | null>>;
  lastChr: string | null;
  constructor(pattern: Pattern);
  makeRootState(context: W0Context): ExpressionResult;
  step0(atStart: boolean, atEnd: boolean, idx: number, nextChr: string | null);
  step1(chr: string);
}