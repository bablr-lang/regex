/* @macrome
 * @generatedby @macrome/generator-typescript
 * @generatedfrom ./ast.ts#1647109390478
 * This file is autogenerated. Please do not edit it directly.
 * When editing run `npx macrome watch` then change the file this is generated from.
 */
"use strict";
Object.defineProperty(exports, "__esModule", {
  value: true
});

Object.defineProperty(exports, "Parser", {
  enumerable: true,

  get: function() {
    return _regexpp.RegExpParser;
  }
});

(exports.isAnchored = (exports.getCharSetDesc = (exports.SimpleVisitor = void 0)));
(exports.visit = visit);

var _regexpp = require("regexpp");

class SimpleVisitor {
  constructor(visitors) {
    this.visitors = visitors;
  }

  visit(node, state) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return this.visitors[node.type](node, state, (node) => this.visit(node, state));
  }
}

exports.SimpleVisitor = SimpleVisitor;

function visit(node, state, visitors) {
  return new SimpleVisitor(visitors).visit(node, state);
}

const literalNames = {
  any: '.',
  digit: '\\d',
  space: '\\s',
  word: '\\w',
};

const getCharSetDesc = (node) => {
  if (node.kind === 'property') {
    return `\\p{${node.key}}`;
  } else {
    return literalNames[node.kind];
  }
};

exports.getCharSetDesc = getCharSetDesc;

const isAnchored = (pattern) =>
  pattern.alternatives.every((alt) => {
    if (!alt.elements.length) return false;
    const first = alt.elements[0];
    // If first is a group we could recurse but I don't see much point.
    if (first.type !== 'Assertion' || first.kind !== 'start') return false;
  });

exports.isAnchored = isAnchored;
