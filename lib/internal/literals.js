/* @macrome
 * @generatedby @macrome/generator-typescript
 * @generatedfrom ./literals.ts#1653680124266
 * This file is autogenerated. Please do not edit it directly.
 * When editing run `npx macrome watch` then change the file this is generated from.
 */
"use strict";
Object.defineProperty(exports, "__esModule", {
  value: true
});

(exports.testWord = (exports.testSpace = (exports.testProperty = (exports.testNotNewline = (exports.testDigit = (exports.testAny = (exports.getTester = (exports.getCharTester = (exports.getCharSetTester = (exports.getCharClassTester = (exports.getCharClassRangeTester = (exports.code = void 0))))))))))));
const code = (str) => str.charCodeAt(0);
exports.code = code;
const upperValue = (c) => String.fromCharCode(c).toUpperCase().charCodeAt(0);
const inRange = (value, lo, hi) => value >= lo && value <= hi;

const c_ = code('_');
const ca = code('a');
const cz = code('z');
const cA = code('A');
const cZ = code('Z');
const c0 = code('0');
const c9 = code('9');
const cSP = code(' ');
const cCR = code('\r');
const cLF = code('\n');
const cHT = code('\t');
const cVT = code('\v');
const cFF = code('\f');

const testNotNewline = (c) => {
  return c !== cCR && c !== cLF && c !== 0x2028 && c !== 0x2029;
};

exports.testNotNewline = testNotNewline;

const testDigit = (c) => {
  return inRange(c, c0, c9);
};

exports.testDigit = testDigit;

const testSpace = (c) => {
  return (c === cSP ||
  c === cCR ||
  c === cLF ||
  c === cHT ||
  c === cVT ||
  c === cFF ||
  inRange(c, 0x2000, 0x200a) ||
  c === 0x00a0 ||
  c === 0x1680 ||
  c === 0x2028 ||
  c === 0x2029 ||
  c === 0x202f ||
  c === 0x205f ||
  c === 0x3000 || c === 0xfeff);
};

exports.testSpace = testSpace;

const testWord = (c) => {
  return inRange(c, cA, cZ) || inRange(c, ca, cz) || inRange(c, c0, c9) || c === c_;
};

exports.testWord = testWord;
const testAny = () => true;
exports.testAny = testAny;
const testProperty = () => false;
exports.testProperty = testProperty;

const testers = {
  digit: testDigit,
  space: testSpace,
  property: testProperty,
  word: testWord,
  any: testAny,
};

const getCharTester = (node, flags) => {
  if (flags.ignoreCase) {
    const value = upperValue(node.value);
    return (c) => upperValue(c) === value;
  } else {
    const { value } = node;
    return (c) => value === c;
  }
};

exports.getCharTester = getCharTester;

const getCharSetTester = (node, flags) => {
  if (node.kind === 'any' && !flags.dotAll) {
    return testNotNewline;
  } else {
    return testers[node.kind];
  }
};

exports.getCharSetTester = getCharSetTester;

const getCharClassRangeTester = (node, flags) => {
  if (flags.ignoreCase) {
    const upperMin = upperValue(node.min.value);
    const upperMax = upperValue(node.max.value);
    return (c) => inRange(upperValue(c), upperMin, upperMax);
  } else {
    const min = node.min.value;
    const max = node.max.value;
    return (c) => inRange(c, min, max);
  }
};

exports.getCharClassRangeTester = getCharClassRangeTester;

const getCharClassTester = (node, flags) => {
  const testers = node.elements.map((node) => getTester(node, flags));
  return (c) => testers.findIndex((tester) => tester(c)) >= 0;
};

exports.getCharClassTester = getCharClassTester;

const getTester = (node, flags) => {
  switch (node.type) {
    case 'CharacterSet':
      return getCharSetTester(node, flags);
    case 'CharacterClass':
      return getCharClassTester(node, flags);
    case 'CharacterClassRange':
      return getCharClassRangeTester(node, flags);
    case 'Character':
      return getCharTester(node, flags);
    default:
      throw new Error(`${node.type} cannot be tested`);
  }
};

exports.getTester = getTester;
